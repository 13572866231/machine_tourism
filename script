receipts <- read.csv("quarterly_receipts.csv")# Read in data
googletrends <- read.csv("google_trends.csv")

# convert to time series
quarterly_receipts <- ts(receipts$Tourism.receipts, start=c(2005, 1), end=c(2016, 3), frequency=4) 

# Required packages
library(corrplot)
library(dplyr)
library(caret)
library(dygraphs)

#Set seed
seed <-777

#Subset
tour.us.data  <- select(googletrends,contains("United.States"))
tour.ven.data <- select(googletrends,contains("Venezuela"))
tour.col.data <- select(googletrends,contains("Colombia"))
tour.ned.data <- select(googletrends,contains("Netherlands"))
tour.can.data <- select(googletrends,contains("Canada"))

# calculate and plot correlation matrix
corMat_tour.us.data <- cor(tour.us.data[, -1])
corMat_tour.ven.data <- cor(tour.ven.data[, -1])
corMat_tour.col.data <- cor(tour.col.data[, -1])
corMat_tour.ned.data <- cor(tour.ned.data[, -1])
corMat_tour.can.data <- cor(tour.can.data[, -1])

corrplot.mixed(corMat_tour.us.data,  order = "hclust", upper ="pie")
corrplot.mixed(corMat_tour.ven.data, order = "hclust", upper ="pie")
corrplot.mixed(corMat_tour.col.data, order = "hclust", upper ="pie")
corrplot.mixed(corMat_tour.ned.data, order = "hclust", upper ="pie")
corrplot.mixed(corMat_tour.can.data, order = "hclust", upper ="pie")

# Principle component
pca<-prcomp(googletrends[, -1],center = TRUE,
            
            scale. = TRUE) 
print(pca)
screeplot(pca, type="lines")
screeplot(pca)
summary(pca)

pca1 <- pca$x [,1]
pca2 <- pca$x [,2]
pca3 <- pca$x [,3]
pca4 <- pca$x [,4]
pca4 <- pca$x [,5]

pca1 <- ts(pca1, start=c(2004, 1), end=c(2017, 2), frequency=12) 
pca2 <- ts(pca2, start=c(2004, 1), end=c(2017, 2), frequency=12) 
pca3 <- ts(pca3, start=c(2004, 1), end=c(2017, 2), frequency=12) 
pca4 <- ts(pca4, start=c(2004, 1), end=c(2017, 2), frequency=12) 
pca5 <- ts(pca4, start=c(2004, 1), end=c(2017, 2), frequency=12) 

td <-td(quarterly_receipts ~ pca1 + pca2 + pca3 + pca4 + pca5)
td <-td(quarterly_receipts ~ pca1 +  pca3)

pcagraph <- cbind(pca1, pca3)
dygraph(pcagraph, main="Principle component series")

receipts_monthly <- predict(td)
summary(td)
plot(td)

receipts_yoy <- diff(receipts_monthly/ (lag(receipts_monthly,12)))*100
summary(receipts_yoy)
dygraph(receipts_yoy, main="Tourism reciepts YOY growth")

# not sure about this one
#googletrends$receipts_monthly <- as.data.frame(receipts_monthly)       

#Set seed
set.seed(seed)

# Machine learning not working just yet
y<-receipts_yoy
x<-googletrends%>%
        select(-Month)
set.seed(seed)
fit<-randomForest(x,y, data=googletrends, ntree=2000)
fit
set.seed(seed)

par(mfrow=c(1,2))
plot(fit, main='')
varImpPlot(fit, main='')
par(mfrow=c(1,1))
pd<-cbind(ltg[,c("date","gdp")],fit$predicted)


rfplot<-ltc%>%
        select(-c(date))%>%
        zoo(ltc$date)%>%
        rollmean(12,align="right", fill=NA)%>%
        lapply(Delt,k=12)%>%
        lapply("*",100)%>%
        data.frame()%>%
        cbind(ltc$date)
names(rfplot)[21]<-"date"
rfpredx<-rfplot%>%
        filter(date>=as.Date("1997/12/1"))%>%
        select(-gdp)
rfpredy<-cbind(rfpredx$date,data.frame(predict(fit,rfpredx[,-20])))
names(rfpredy)<-c("date", "growth")
plot(rfpredy$date,rfpredy$growth, type="l", col=2, xlab="", ylab="GDP growth", main="Random Forests")
points(pd$date,pd$gdp)
rftrain<-rfpredy%>%
        filter(date<=as.Date("2010/12/1"))
rftest<-rfpredy%>%
        filter(date>as.Date("2010/12/1"))
tail(rftest)



# (don't remember where this is coming from)
#define the control using a random forest selection function with cross validation
#control <- rfeControl(functions = rfFuncs, method = "cv", number = 10)
